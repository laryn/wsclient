<?php
// $Id$

/**
 * @file
 * Web service client SOAP support.
 */

/**
 * Implements hook_wsclient_endpoint_types().
 */
function wsclient_soap_wsclient_endpoint_types() {
  return array(
    'soap' => array(
      'label' => t('SOAP'),
      'class' => 'WSClientSOAPEndpoint',
    ),
  );
}

/**
 * A remote endpoint type for invoking SOAP services.
 */
class WSClientSOAPEndpoint extends WSClientEndpoint {

  public function client() {
    if (!isset($this->client)) {
      $options['exceptions'] = TRUE;
      if (!empty($this->service->settings['options'])) {
        $options += $this->service->settings['options'];
      }
      // The url has to point to a WSDL file.
      $this->client = new SOAPClient($this->url, $options);
    }
    return $this->client;
  }

  /**
   * Calls the SOAP service.
   *
   * @param string $operation
   *   The name of the operation to execute.
   * @param array $arguments
   *   Arguments to pass to the service with this operation.
   */
  public function call($operation, $arguments) {
    $client = $this->client();
    try {
      $response = $client->__soapCall($operation, $arguments);
      return $response;
    }
    catch (SoapFault $e) {
      throw new WSClientException('Error invoking the SOAP service %name, operation %operation: %error', array('%name' => $this->service->label, '%operation' => $operation, '%error' => $e->getMessage()));
    }
  }
}

/**
 * Convert metadata about data types provided by a SOAPClient into a wsclient
 * compatible data type array.
 *
 * @param array $types
 *   The array containing the struct strings.
 * @return
 *   A data type array with property information.
 */
function wsclient_soap_parse_types(array $types) {
  $wsclient_types = array();
  foreach ($types as $type_string) {
    if (strpos($type_string, 'struct') === 0) {
      $parts = explode('{', $type_string);
      // Cut off struct and whitespaces from type name.
      $type_name = trim(substr($parts[0], 6));
      $wsclient_types[$type_name] = array('label' => $type_name);
      $property_string = $parts[1];
      // Cut off trailing '}'
      $property_string = substr($property_string, 0, -1);
      $properties = explode(';', $property_string);
      // Remove last empty element
      array_pop($properties);
      foreach ($properties as $property_string) {
        // Cut off white spaces.
        $property_string = trim($property_string);
        $parts = explode(' ', $property_string);
        $property_type = $parts[0];
        $property_name = $parts[1];
        $wsclient_types[$type_name]['property info'][$property_name] = array(
          'type' => wsclient_soap_type_mapper($property_type),
        );
      }
    }
  }
  return $wsclient_types;
}

/**
 * Convert metadata about operations provided by a SOAPClient into a wsclient
 * compatible operations array.
 *
 * @param array $operations
 *   The array containing the operation signature strings.
 * @return
 *   An operations array with parameter information.
 */
function wsclient_soap_parse_operations(array $operations) {
  $wsclient_operations = array();
  foreach ($operations as $operation) {
    $parts = explode(' ', $operation);
    $return_type = wsclient_soap_type_mapper($parts[0]);
    $name_parts = explode('(', $parts[1]);
    $op_name = $name_parts[0];
    $wsclient_operations[$op_name] = array(
      'label' => $op_name,
      'result' => array('type' => $return_type),
    );
    $parts = explode('(', $operation);
    // Cut off trailing ')'.
    $param_string = substr($parts[1], 0, -1);
    $parameters = explode(',', $param_string);
    foreach ($parameters as $parameter) {
      $parts = explode(' ', $parameter);
      $param_type = $parts[0];
      // Remove leading '$' from parameter name.
      $param_name = substr($parts[1], 1);
      $wsclient_operations[$op_name]['parameter'][$param_name] = array(
        'type' => wsclient_soap_type_mapper($param_type),
      );
    }
  }
  return $wsclient_operations;
}

/**
 * Maps data type names from SOAPClient to wsclient/rules internals.
 */
function wsclient_soap_type_mapper($type) {
  switch ($type) {
    case 'int':
      return 'integer';
    case 'string':
      return 'text';
  }
  // Check for list types.
  if (strpos($type, 'ArrayOf') === 0) {
    return 'list<' . substr($type, 7) . '>';
  }
  return $type;
}
